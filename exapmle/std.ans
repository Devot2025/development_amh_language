@ module is hash process
#module

@:
================================================================================
Module name: std  (file name: std)

File name and #module:
  - This file’s name is **"std"**.
  - With `#module` (1 file = 1 module) and the Hash Process special rule,
    the **entire file becomes the module "std"**.
  - On import/include, the module is **auto-instantiated (class-like)**.
    It is typically created **once at load time**; re-including reuses
    the same instance.

Purpose:
  - Provide thin wrappers over the runtime’s virtual I/O primitives
    (____virtual__write / ____virtual__read).
  - Expose ANSI-like helpers for standard streams (stdin=0, stdout=1, stderr=2).

About “Hash Process”:
  - Here, “Hash Process” names a special process-layer module in this language/runtime
    (not cryptographic hashing). It centralizes low-level I/O so other code uses
    this module rather than calling the raw primitives directly.

Publication model (general vs. special case):
  - **General language rule**: this language supports a publication model;
    `public` / `private` visibility can be specified in ordinary modules.
  - **Hash Process special rule (applies to this `std` module)**:
      * Attaching explicit visibility (public/private) **is not allowed** here.
      * All symbols are **implicitly public** and exported.
      * If `private` is explicitly written, its handling is **currently undecided (TBD)**.
        - Possible futures: “warn and promote to public” / “compile-time error”, etc.
        - For now, avoid specifying `private` inside this module.

Design notes:
  - Newline policy: `ans_puts*` appends a single `"\n"` to the provided string
    (no check for pre-existing trailing newline).
  - Error handling: return values from `____virtual__write/read` are implementation-defined
    (e.g., bytes written/read, or negative error codes).

--------------------------------------------------------------------------------
abs type rule (type absorption rule)

Overview:
  - Types have a **precedence**; in binary operations the rule set of the
    **higher-precedence type** governs the operation and conversions (“absorption”).
  - “Lower-absorption types follow the rule of higher-absorption types.”

Precedence (high → low):
  ?stack > string >> double > float > int > char > *class > virtuals > $none

Legend:
  >> : very strong precedence (e.g., `string` strongly absorbs others)
   > : normal precedence
“predefined”: per-type special rules can be set separately (note)
   * : without special handling, cannot be absorbed by higher types
   ? : rule not yet defined
   $ : effectively no absorption / no operation

Notes:
  - For `*class`, mixing with higher types like `string` or `int` is an **error**
    unless special handling is provided.
  - `virtuals` / `$none` may be treated as non-operable / invalid in many contexts.

Examples:
  - `string` absorbs lower types by converting them to meaningful textual forms:
      "" + 1     -> "1"
      "" + 1.0   -> "1.0"
  - `double` absorbs lower numeric types by widening:
      1.5 + 1 (int→double) -> 2.5

Application in this module:
  - In `ans_puts`, `str + "\n"` resolves to **string concatenation** because of
    `string`’s very strong absorption (`>>`).
--------------------------------------------------------------------------------

Public API (wrappers):
  ans_puts(str)        : write (str + "\n") to stdout
  ans_puts(str, n)     : write up to n units from (str + "\n") to stdout
  ans_gets()           : read from stdin with the runtime’s default behavior
  ans_gets(n)          : read up to n units from stdin

Runtime primitives (implementation-defined):
  ____virtual__write(stream, str[, n])
    - Writes a buffer to the given stream.
    - Returns: impl-defined (e.g., bytes written, negative error on failure).
  ____virtual__read(stream[, n])
    - Reads from the given stream.
    - Returns: impl-defined (e.g., buffer/string, error/EOF sentinel).
================================================================================
:@


obj ans_puts(obj str){
	@ abs type rule: if either operand is string, '+' resolves to string concatenation (implicit stringification).
	@ Always append a single newline, then write to stdout.
	obj ____out__string = str + "\n";
	return ____virtual__write(stdout, ____out__string);
}

obj ans_puts(obj str, obj n){
	@ abs type rule: if either operand is string, '+' resolves to string concatenation (implicit stringification).
	@ Append a newline, then write at most 'n' units.
	@ NOTE: if n < length(str)+1, the trailing newline may be truncated.
	obj ____out__string = str + "\n";
	return ____virtual__write(stdout, ____out__string, n);
}

obj ans_gets(){
	@ Read from stdin using the runtime’s default length/behavior.
	return ____virtual__read(stdin);
}

obj ans_gets(obj n){
	@ Read at most 'n' units from stdin.
	return ____virtual__read(stdin, n);
}

@ Stream identifiers (UNIX-like): 0 = stdin, 1 = stdout, 2 = stderr
obj stdin;
obj stdout;
obj stderr;

@toplevel return
@ Module init: set stream IDs and return 1 to signal successful setup.
stdin = 0;
stdout = 1;
stderr = 2;
return 1;
